### API Security
* Most APIs involve user registration and logins, so you can track your app's users and grant them privileges. In the Planetary API, I want to allow registration for the planet discovering scientific community. In order to register a new planet or edit or delete an existing planet, you must be logged in. Listing the planets, planet details, and the registration endpoint itself will not require a login. There are several prebuilt login and user management plugins if you don't want to build one yourself. There's Flask-Login, which handles logging in, logging out, and session management. There's also Flask-User, which handles user registration, login, logout, and role based security, like the kind I mentioned earlier. When evaluating these plugins, remember traditionally Flask is used to make traditional template based websites.
* For API projects, I prefer to use a technology called JSON Web Tokens. Most of the time, the app talking to my API is going to be a web app written in something like React or Angular. It could also be a mobile app or a desktop app.
* JSON Web Tokens, or JWT, is an open standard for authenticating and verifying JADA exchanges between two parties. There are libraries for working with JWT in most languages, including Python. I'm not going to go into too much depth on how it works. You can implement it black box style, which is what we'll do here.
* Obviously this is supported in HTML but most other languages and environments allow you to construct HTML form fields for use with APIs. You might want to support a pure JSON post in your API and I'll show you how to do that a little bit later. Getting back to keeping it simple, let's grab the email address from the submitted form. I'll type in email equals request.form email. Next I need to see if this user's already registered or not, so I'm going to create a variable called test and I'm going to type in User.query.filter_by and I'll type in email equals email.first. So, this is going to call the database and we're going to look for a single user with the email address that just got passed in. Now we don't need to deserialize this, we don't need Marshmallow for this. I just want to see if there's one there. So, let's check it. I'll say if test and essentially what we're doing here is we're checking to see the type is none or if there's actually an object there. If there is an object there, then we know that email already exists, so let's return jsonify and we'll set our message equal to That email already exists.
* You can see that when I'm using named parameters in PyCharm, it gives me the option to just start typing it in and it gives me the one with the equals sign. I find that just really handy because I really like using named parameters whenever possible. 
* I'll type in test = User.query.filter_by. This is going to generate a select statement against our user table. We're going to limit our search by adding email=email and password=password. Then on the tail end of this, I'll add .first to get back the first record. We're only expecting there to be one entry since it's illegal to have two user IDs concurrently in the database.
* Now we can submit a regular JSON object in here. Don't forget JSON objects are different from JavaScript objects in that they have to have the double quotes around them to define the different elements.
*  pythonhosted.org/flask-mail.